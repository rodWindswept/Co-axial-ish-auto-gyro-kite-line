import { DesignParams, SimulationResult } from '../types';

/**
 * A simplified Blade Element Momentum Theory (BEMT) approximation 
 * for a kite-mounted autogyro.
 */
export const calculatePhysics = (params: DesignParams): SimulationResult => {
  const {
    bladeLength,
    bladeChord,
    bladePitch,
    windSpeed,
    lineAngle,
    rotorMass,
    rotorTilt = 0
  } = params;

  // Constants
  const airDensity = 1.225; // kg/m^3
  const bladeCount = 2;
  const rotorRadius = bladeLength; // Assuming hub is negligible for aero area calculation
  const rotorArea = Math.PI * Math.pow(rotorRadius, 2);
  const solidity = (bladeCount * bladeChord * bladeLength) / rotorArea;

  // Angle of Attack (AoA) Calculation
  // Base alpha is (90 - lineAngle).
  // Rotor Tilt (Spherical Bearing) modifies this. 
  // Positive tilt = tilting back (increasing alpha).
  const effectiveAlphaDeg = (90 - lineAngle) + rotorTilt;
  const discAngleRad = effectiveAlphaDeg * (Math.PI / 180);
  
  // Approximate RPM based on autorotation equilibrium
  // Higher alpha generally means higher RPM (up to stall point around 15-20 deg effective inflow)
  // We clamp responsiveness for simulation stability.
  const expectedTipSpeedRatio = 4 + (effectiveAlphaDeg / 15); 
  const tipSpeed = windSpeed * expectedTipSpeedRatio;
  const radsPerSecond = tipSpeed / rotorRadius;
  const rpm = (radsPerSecond * 60) / (2 * Math.PI);

  // Lift Coefficient (Approximate based on pitch and solidity)
  const effPitchRad = bladePitch * (Math.PI / 180);
  // Modulate Cl by alpha too (simplified)
  const cl_avg = 0.8 * Math.sin(effPitchRad + 0.1) * (1 + Math.sin(discAngleRad)*0.5); 

  // Thrust/Tension generation (Axial force along the line)
  
  // Rotor Lift (Perpendicular to incoming flow locally, but roughly normal to disc)
  // L = 0.5 * rho * V^2 * Area * Cl_rotor
  const v_effective = Math.sqrt(Math.pow(windSpeed, 2) + Math.pow(tipSpeed * 0.7, 2));
  const liftForce = 0.5 * airDensity * Math.pow(v_effective, 2) * (bladeChord * bladeLength * bladeCount) * cl_avg;

  // Rotor Drag (Profile + Induced)
  const cd_avg = 0.05 + (Math.pow(cl_avg, 2) / (Math.PI * 0.8)); // Polar approx
  const dragForce = 0.5 * airDensity * Math.pow(v_effective, 2) * (bladeChord * bladeLength * bladeCount) * cd_avg;

  // Total Aerodynamic Thrust generated by the rotor (along rotor axis)
  // In autorotation, the net force vector tilts slightly back from the axis of rotation.
  const totalRotorThrust = liftForce * Math.cos(0.1) + dragForce * Math.sin(0.1);

  // Project forces onto the kite line. 
  // The rotor axis is tilted by `rotorTilt` relative to the line.
  // Effective Tension = TotalThrust * cos(rotorTilt)
  const tiltRad = rotorTilt * (Math.PI / 180);
  const generatedThrust = totalRotorThrust * Math.cos(tiltRad);

  // Stability
  // Teetering rotors are generally stable, but high RPM + low mass = instability.
  // High tilt angles might induce precession or instability.
  const stabilityScore = Math.min(100, Math.max(0, (rotorMass * rpm) / 10 - Math.abs(rotorTilt) * 2));

  // Power (if we were extracting it, simpler calc)
  const powerOutput = generatedThrust * windSpeed * 0.3; // Betz limit ish

  return {
    rpm: Math.round(rpm),
    generatedThrust: parseFloat(generatedThrust.toFixed(2)),
    totalRotorThrust: parseFloat(totalRotorThrust.toFixed(2)),
    lift: parseFloat(liftForce.toFixed(2)),
    drag: parseFloat(dragForce.toFixed(2)),
    tipSpeed: parseFloat(tipSpeed.toFixed(2)),
    tipSpeedRatio: parseFloat(expectedTipSpeedRatio.toFixed(2)),
    stabilityScore: Math.round(stabilityScore),
    powerOutput: parseFloat(powerOutput.toFixed(2))
  };
};